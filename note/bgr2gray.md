 代码：`cv/arm/bgr2gray.cpp`



测试共分为两部分，第一部分是正确性测试：将优化后的算子输出和原始版本的算子输出做比较，保证优化不影响算子的结果。第二部分是耗时测试，采用MNN的策略1）进行一定次数的warm up；2）循环一定次数后挂起一段时间后，再继续执行。


测试机型：小米 10S
| 实现/耗时(ms)           | 320x240    | 1280x720  | 1920x1080 | 3840x2160 |
| ----------------------- | ---------- | --------- | --------- | --------- |
| naive                   | 0.747      | 8.273     | 27.546    | 110.249   |
| opencv实现              | 0.0636     | 0.733     | 2.428     | 9.763     |
| **neon加速** **(-70%)** | **0.0170** | **0.219** | **0.710** | **2.944** |
| neon_v2                 | 0.0193     | 0.237     | 0.765     | 3.105     |

测试机型：M1 Pro

| 实现/耗时(ms) | 320x240    | 1280x720   | 1920x1080 | 3840x2160 |
| ------------- | ---------- | ---------- | --------- | --------- |
| naive         | 0.050      | 0.577      | 1.299     | 5.387     |
| opencv实现    | 0.016      | 0.156      | 0.356     | 1.424     |
| neon加速      | 0.007      | 0.0727     | 0.166     | 0.683     |
| **neon_v2**   | **0.0052** | **0.0537** | **0.124** | **0.519** |

### bgr2gray neon加速

数据见 上表 **neon加速** 这一行。

opencv的[BGR2Gray实现](https://github.com/opencv/opencv/blob/master/modules/imgproc/src/color_rgb.simd.hpp#L666) 比我的实现要慢许多，原因有两点：

1. 这里使用u8代替浮点计算，opencv采用s16(short)代替浮点计算。数据吞吐量是我的1/2。这是主要原因。

2. opencv做了额外的round操作，即 `short gray = r * RY15 + g * GY15 + B * BY15 + 2^14   `  ，相当于  

   ```c++
   float ff = 1.4f;
   int i = int(ff + 0.5f);
   ```




### 还能更快吗？neon_v2

观察neon实现在读取、写入内存时的代码：

```c++
//读取bgr
uint8x8x3_t v_bgr = vld3_u8(src);
...
//写入gray
vst1_u8(dst, v_gray);
```

都是在以 64-bit 宽度进行内存交换，并没有使用128-bit宽度的 `vld3q_u8` 和 `vst1q_u8` intrinsics。如果使用 `vld3q_u8` 和 `vst1q_u8` ，可以减少访存次数。

使用该思路优化，在mac M1上可以进一步提升25%左右的速度，但在安卓端起到了反作用，见上表 **neon_v2** 这一行。可见优化策略还是与target device强相关的。





## 注意事项

1. 参数需要转整型：RGB 2 GRAY的计算公式是 

   ![img](https://pic3.zhimg.com/80/v2-ac351cfe72ac84b62639a0bfce55334e_1440w.webp)

   但是像素值是u8类型，无法和f32类型的参数做运算，所以要将参数定点化，而且要定点化为u8，这样才能运算

2. 无法做u8的向量 - 标量 乘法

   检索neon intrinsic，发现没有 vmull_n_u8 指令。

   只能将标量dup之后，做向量 - 向量乘法